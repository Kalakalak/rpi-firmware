diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index 802720e..115cb21 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -43,6 +43,8 @@ dtb-$(CONFIG_ARCH_AT91)	+= sama5d35ek.dtb
 
 dtb-$(CONFIG_ARCH_ATLAS6) += atlas6-evb.dtb
 
+dtb-$(CONFIG_BCM2708_DT) += bcm2708-rpi-b.dtb
+dtb-$(CONFIG_BCM2708_DT) += bcm2708-rpi-b-test.dtb
 dtb-$(CONFIG_ARCH_BCM2835) += bcm2835-rpi-b.dtb
 dtb-$(CONFIG_ARCH_BCM) += bcm11351-brt.dtb \
 	bcm28155-ap.dtb
diff --git a/arch/arm/boot/dts/bcm2708-rpi-b-test.dts b/arch/arm/boot/dts/bcm2708-rpi-b-test.dts
new file mode 100644
index 0000000..3e8ba92
--- /dev/null
+++ b/arch/arm/boot/dts/bcm2708-rpi-b-test.dts
@@ -0,0 +1,87 @@
+/dts-v1/;
+
+/include/ "bcm2708-rpi.dtsi"
+
+/ {
+	gpio_keys {
+		compatible = "gpio-keys";
+		pinctrl-names = "default";
+		pinctrl-0 = <&gpio_keys_pins>;
+
+		status = "okay";
+
+		#address-cells = <1>;
+		#size-cells = <0>;
+		autorepeat;
+		button@a {
+			label = "GPIO Key A";
+			linux,code = <30>;
+			gpios = <&gpio 23 1>;
+		};
+		button@b {
+			label = "GPIO Key B";
+			linux,code = <48>;
+			gpios = <&gpio 22 1>;
+		};
+	};
+};
+
+&gpio {
+	gpio_keys_pins: gpio_keys {
+		brcm,pins = <23 22>;
+		brcm,function = <0>; /* GPIO in */
+		brcm,pull = <2>; /* pull up */
+	};
+};
+
+&spi0 {
+	status = "okay";
+
+	spidev@0{
+		compatible = "spidev";
+		reg = <0>;	/* CE0 */
+		#address-cells = <1>;
+		#size-cells = <0>;
+		spi-max-frequency = <500000>;
+		// Mode 0 (CPOL = 0, CPHA = 0)
+		status = "okay";
+	};
+
+	spidev@1{
+		compatible = "spidev";
+		reg = <1>;	/* CE1 */
+		#address-cells = <1>;
+		#size-cells = <0>;
+		spi-max-frequency = <500000>;
+		// Mode 0 (CPOL = 0, CPHA = 0)
+		status = "disabled";
+	};
+
+	tsc2046@1 {
+		compatible = "ti,tsc2046";
+		reg = <1>;	/* CE1 */
+		interrupts = <3 17>;	/* bank 3 is GPIO interrupts */
+		spi-max-frequency = <2000000>;
+		pendown-gpio = <&gpio 17 0>;
+
+		ti,x-min = /bits/ 16 <230>;
+		ti,x-max = /bits/ 16 <3850>;
+		ti,y-min = /bits/ 16 <190>;
+		ti,y-max = /bits/ 16 <3850>;
+		ti,x-plate-ohms = /bits/ 16 <60>;
+		ti,pressure-max = /bits/ 16 <255>;
+
+		linux,wakeup;
+		status = "okay";
+	};
+};
+
+&i2c0 {
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&i2c1 {
+	status = "okay";
+	clock-frequency = <100000>;
+};
diff --git a/arch/arm/boot/dts/bcm2708-rpi-b.dts b/arch/arm/boot/dts/bcm2708-rpi-b.dts
new file mode 100644
index 0000000..4a172ab
--- /dev/null
+++ b/arch/arm/boot/dts/bcm2708-rpi-b.dts
@@ -0,0 +1,37 @@
+/dts-v1/;
+
+/include/ "bcm2708-rpi.dtsi"
+
+&spi0 {
+	status = "okay";
+
+	spidev@0{
+		compatible = "spidev";
+		reg = <0>;	/* CE0 */
+		#address-cells = <1>;
+		#size-cells = <0>;
+		spi-max-frequency = <500000>;
+		// Mode 0 (CPOL = 0, CPHA = 0)
+		status = "okay";
+	};
+
+	spidev@1{
+		compatible = "spidev";
+		reg = <1>;	/* CE1 */
+		#address-cells = <1>;
+		#size-cells = <0>;
+		spi-max-frequency = <500000>;
+		// Mode 0 (CPOL = 0, CPHA = 0)
+		status = "okay";
+	};
+};
+
+&i2c0 {
+	status = "okay";
+	clock-frequency = <100000>;
+};
+
+&i2c1 {
+	status = "okay";
+	clock-frequency = <100000>;
+};
diff --git a/arch/arm/boot/dts/bcm2708-rpi.dtsi b/arch/arm/boot/dts/bcm2708-rpi.dtsi
new file mode 100644
index 0000000..145eed1
--- /dev/null
+++ b/arch/arm/boot/dts/bcm2708-rpi.dtsi
@@ -0,0 +1,44 @@
+/include/ "bcm2708.dtsi"
+
+/ {
+	compatible = "brcm,bcm2708";
+	model = "Raspberry Pi Model B";
+
+	aliases {
+		spi0 = &spi0;
+		i2c0 = &i2c0;
+		i2c1 = &i2c1;
+	};
+};
+
+&gpio {
+	spi0_pins: spi0 {
+		brcm,pins = <7 8 9 10 11>;
+		brcm,function = <4>; /* alt0 */
+	};
+
+	i2c0_pins: i2c0 {
+		brcm,pins = <0 1>;
+		brcm,function = <4>; /* alt0 */
+	};
+
+	i2c1_pins: i2c1 {
+		brcm,pins = <2 3>;
+		brcm,function = <4>; /* alt0 */
+	};
+};
+
+&spi0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi0_pins>;
+};
+
+&i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0_pins>;
+};
+
+&i2c1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c1_pins>;
+};
diff --git a/arch/arm/boot/dts/bcm2708.dtsi b/arch/arm/boot/dts/bcm2708.dtsi
new file mode 100644
index 0000000..1a2bce2
--- /dev/null
+++ b/arch/arm/boot/dts/bcm2708.dtsi
@@ -0,0 +1,88 @@
+/include/ "skeleton.dtsi"
+
+/ {
+	compatible = "brcm,bcm2708";
+	model = "BCM2708";
+
+	interrupt-parent = <&intc>;
+
+	chosen {
+		bootargs = "earlyprintk console=ttyAMA0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ";
+	};
+
+	axi {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0x7e000000 0x20000000 0x02000000>;
+
+		intc: interrupt-controller {
+			compatible = "brcm,bcm2708-armctrl-ic";
+			reg = <0x7e00b200 0x200>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+		};
+
+		uart@20201000 {
+			compatible = "brcm,bcm2835-pl011", "arm,pl011", "arm,primecell";
+			reg = <0x7e201000 0x1000>;
+			interrupts = <2 25>;
+			clock-frequency = <3000000>;
+			arm,primecell-periphid = <0x00241011>;
+		};
+
+		gpio: gpio {
+			compatible = "brcm,bcm2708-gpio";
+			reg = <0x7e200000 0xb4>;
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+		spi0: spi@20204000 {
+			compatible = "brcm,bcm2708-spi";
+			reg = <0x7e204000 0x1000>;
+			interrupts = <2 22>;
+			clocks = <&clk_spi>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		i2c0: i2c@20205000 {
+			compatible = "brcm,bcm2708-i2c";
+			reg = <0x7e205000 0x1000>;
+			interrupts = <2 21>;
+			clocks = <&clk_i2c>;
+			status = "disabled";
+		};
+
+		i2c1: i2c@20804000 {
+			compatible = "brcm,bcm2708-i2c";
+			reg = <0x7e804000 0x1000>;
+			interrupts = <2 21>;
+			clocks = <&clk_i2c>;
+			status = "disabled";
+		};
+
+	};
+
+	clocks {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		clk_i2c: i2c {
+			compatible = "fixed-clock";
+			reg = <1>;
+			#clock-cells = <0>;
+			clock-frequency = <250000000>;
+		};
+
+		clk_spi: spi {
+			compatible = "fixed-clock";
+			reg = <2>;
+			#clock-cells = <0>;
+			clock-frequency = <250000000>;
+		};
+	};
+};
diff --git a/arch/arm/mach-bcm2708/Kconfig b/arch/arm/mach-bcm2708/Kconfig
index e151ed4..c3ab8e9 100644
--- a/arch/arm/mach-bcm2708/Kconfig
+++ b/arch/arm/mach-bcm2708/Kconfig
@@ -38,4 +38,18 @@ config BCM2708_SPIDEV
 	default y
 	help
 	  Binds spidev driver to the SPI0 master
+
+config BCM2708_DT
+	bool "Use Device Tree"
+	depends on MACH_BCM2708
+	default n
+	select USE_OF
+	select COMMON_CLK
+	select COMMON_CLK_DEBUG
+	select BCM2708_GPIO
+	select PINCTRL
+	select PINCTRL_BCM2708
+	help
+	  Device Tree and pinctrl support
+
 endmenu
diff --git a/arch/arm/mach-bcm2708/armctrl.c b/arch/arm/mach-bcm2708/armctrl.c
index 274aa30..3e60999 100644
--- a/arch/arm/mach-bcm2708/armctrl.c
+++ b/arch/arm/mach-bcm2708/armctrl.c
@@ -23,6 +23,8 @@
 #include <linux/version.h>
 #include <linux/syscore_ops.h>
 #include <linux/interrupt.h>
+#include <linux/irqdomain.h>
+#include <linux/of.h>
 
 #include <asm/mach/irq.h>
 #include <mach/hardware.h>
@@ -79,6 +81,100 @@ static void armctrl_unmask_irq(struct irq_data *d)
 	}
 }
 
+#if defined(CONFIG_BCM2708_DT)
+
+#define NR_IRQS_BANK0           21
+#define NR_BANKS                3 + 1
+#define IRQS_PER_BANK           32
+
+/* from drivers/irqchip/irq-bcm2835.c */
+static int armctrl_xlate(struct irq_domain *d, struct device_node *ctrlr,
+        const u32 *intspec, unsigned int intsize,
+        unsigned long *out_hwirq, unsigned int *out_type)
+{
+        if (WARN_ON(intsize != 2))
+                return -EINVAL;
+
+        if (WARN_ON(intspec[0] >= NR_BANKS))
+                return -EINVAL;
+
+        if (WARN_ON(intspec[1] >= IRQS_PER_BANK))
+                return -EINVAL;
+
+        if (WARN_ON(intspec[0] == 0 && intspec[1] >= NR_IRQS_BANK0))
+                return -EINVAL;
+
+	if (intspec[0] == 0)
+		*out_hwirq = ARM_IRQ0_BASE + intspec[1];
+	else if (intspec[0] == 1)
+		*out_hwirq = ARM_IRQ1_BASE + intspec[1];
+	else if (intspec[0] == 2)
+		*out_hwirq = ARM_IRQ2_BASE + intspec[1];
+	else /* use bank 3 for GPIO interrupts */
+		*out_hwirq = GPIO_IRQ_START + intspec[1];
+
+	/* reverse remap_irqs[] */
+	switch (*out_hwirq) {
+	case INTERRUPT_VC_JPEG:
+		*out_hwirq = INTERRUPT_JPEG;
+		break;
+	case INTERRUPT_VC_USB:
+		*out_hwirq = INTERRUPT_USB;
+		break;
+	case INTERRUPT_VC_3D:
+		*out_hwirq = INTERRUPT_3D;
+		break;
+	case INTERRUPT_VC_DMA2:
+		*out_hwirq = INTERRUPT_DMA2;
+		break;
+	case INTERRUPT_VC_DMA3:
+		*out_hwirq = INTERRUPT_DMA3;
+		break;
+	case INTERRUPT_VC_I2C:
+		*out_hwirq = INTERRUPT_I2C;
+		break;
+	case INTERRUPT_VC_SPI:
+		*out_hwirq = INTERRUPT_SPI;
+		break;
+	case INTERRUPT_VC_I2SPCM:
+		*out_hwirq = INTERRUPT_I2SPCM;
+		break;
+	case INTERRUPT_VC_SDIO:
+		*out_hwirq = INTERRUPT_SDIO;
+		break;
+	case INTERRUPT_VC_UART:
+		*out_hwirq = INTERRUPT_UART;
+		break;
+	case INTERRUPT_VC_ARASANSDIO:
+		*out_hwirq = INTERRUPT_ARASANSDIO;
+		break;
+	}
+
+        *out_type = IRQ_TYPE_NONE;
+        return 0;
+}
+
+static struct irq_domain_ops armctrl_ops = {
+        .xlate = armctrl_xlate
+};
+
+void __init armctrl_dt_init(void)
+{
+	struct device_node *np;
+	struct irq_domain *domain;
+
+	np = of_find_compatible_node(NULL, NULL, "brcm,bcm2708-armctrl-ic");
+	if (!np)
+		return;
+
+        domain = irq_domain_add_legacy(np, NR_IRQS, IRQ_ARMCTRL_START, 0,
+					&armctrl_ops, NULL);
+        WARN_ON(!domain);
+}
+#else
+void __init armctrl_dt_init(void) { }
+#endif /* CONFIG_BCM2708_DT */
+
 #if defined(CONFIG_PM)
 
 /* for kernels 3.xx use the new syscore_ops apis but for older kernels use the sys dev class */
@@ -215,5 +311,6 @@ int __init armctrl_init(void __iomem * base, unsigned int irq_start,
 
 	armctrl_pm_register(base, irq_start, resume_sources);
 	init_FIQ(FIQ_START);
+	armctrl_dt_init();
 	return 0;
 }
diff --git a/arch/arm/mach-bcm2708/bcm2708.c b/arch/arm/mach-bcm2708/bcm2708.c
index 95a47fa..48da0f1 100644
--- a/arch/arm/mach-bcm2708/bcm2708.c
+++ b/arch/arm/mach-bcm2708/bcm2708.c
@@ -34,6 +34,9 @@
 #include <linux/spi/spi.h>
 #include <linux/w1-gpio.h>
 
+
+#include <linux/clk/bcm2835.h>
+#include <linux/of_platform.h>
 #include <linux/version.h>
 #include <linux/clkdev.h>
 #include <asm/system.h>
@@ -773,10 +776,32 @@ static void bcm2708_power_off(void)
 	}
 }
 
+#if defined(CONFIG_BCM2708_DT)
+static void __init bcm2708_dt_init(void)
+{
+	int ret;
+
+	bcm2835_init_clocks();
+
+	ret = of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);
+	if (ret) {
+		early_printk("bcm2708: of_platform_populate failed: %d\n", ret);
+		pr_emerg("bcm2708: of_platform_populate failed: %d\n", ret);
+		BUG();
+	}
+}
+#else
+static void __init bcm2708_dt_init(void) { }
+#endif /* CONFIG_BCM2708_DT */
+
+
 void __init bcm2708_init(void)
 {
 	int i;
 
+
+	bcm2708_dt_init();
+
 #if defined(CONFIG_BCM_VC_CMA)
 	vc_cma_early_init();
 #endif
@@ -812,9 +837,6 @@ void __init bcm2708_init(void)
 	for (i = 0; i < ARRAY_SIZE(bcm2708_alsa_devices); i++)
 		bcm_register_device(&bcm2708_alsa_devices[i]);
 
-	bcm_register_device(&bcm2708_spi_device);
-	bcm_register_device(&bcm2708_bsc0_device);
-	bcm_register_device(&bcm2708_bsc1_device);
 
 	bcm_register_device(&bcm2835_hwmon_device);
 	bcm_register_device(&bcm2835_thermal_device);
@@ -1010,6 +1032,11 @@ static void __init board_reserve(void)
 #endif
 }
 
+static const char * const bcm2708_compat[] = {
+	"brcm,bcm2708",
+	NULL
+};
+
 MACHINE_START(BCM2708, "BCM2708")
     /* Maintainer: Broadcom Europe Ltd. */
 	.map_io = bcm2708_map_io,
@@ -1019,6 +1046,7 @@ MACHINE_START(BCM2708, "BCM2708")
 	.init_early = bcm2708_init_early,
 	.reserve = board_reserve,
 	.restart	= bcm2708_restart,
+	.dt_compat = bcm2708_compat,
 MACHINE_END
 
 module_param(boardrev, uint, 0644);
diff --git a/arch/arm/mach-bcm2708/clock.c b/arch/arm/mach-bcm2708/clock.c
index 4fc556e..d4bae02 100644
--- a/arch/arm/mach-bcm2708/clock.c
+++ b/arch/arm/mach-bcm2708/clock.c
@@ -31,6 +31,7 @@
 
 #include "clock.h"
 
+#ifndef CONFIG_BCM2708_DT
 int clk_enable(struct clk *clk)
 {
 	return 0;
@@ -59,3 +60,4 @@ int clk_set_rate(struct clk *clk, unsigned long rate)
 	return -EIO;
 }
 EXPORT_SYMBOL(clk_set_rate);
+#endif
diff --git a/drivers/clk/Makefile b/drivers/clk/Makefile
index 7b11106..fbd422e 100644
--- a/drivers/clk/Makefile
+++ b/drivers/clk/Makefile
@@ -10,6 +10,7 @@ obj-$(CONFIG_COMMON_CLK)	+= clk-mux.o
 obj-$(CONFIG_COMMON_CLK)	+= clk-composite.o
 
 # SoCs specific
+obj-$(CONFIG_BCM2708_DT)	+= clk-bcm2835.o
 obj-$(CONFIG_ARCH_BCM2835)	+= clk-bcm2835.o
 obj-$(CONFIG_ARCH_NOMADIK)	+= clk-nomadik.o
 obj-$(CONFIG_ARCH_HIGHBANK)	+= clk-highbank.o
diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index aba8862..f913158 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -338,7 +338,7 @@ config I2C_AU1550
 
 config I2C_BCM2835
 	tristate "Broadcom BCM2835 I2C controller"
-	depends on ARCH_BCM2835
+	depends on ARCH_BCM2835 || MACH_BCM2708
 	help
 	  If you say yes to this option, support will be included for the
 	  BCM2835 I2C controller.
diff --git a/drivers/i2c/busses/i2c-bcm2708.c b/drivers/i2c/busses/i2c-bcm2708.c
index 7ef126d..bcab70f 100644
--- a/drivers/i2c/busses/i2c-bcm2708.c
+++ b/drivers/i2c/busses/i2c-bcm2708.c
@@ -26,6 +26,7 @@
 #include <linux/spinlock.h>
 #include <linux/clk.h>
 #include <linux/err.h>
+#include <linux/of.h>
 #include <linux/platform_device.h>
 #include <linux/io.h>
 #include <linux/slab.h>
@@ -302,6 +303,21 @@ static int bcm2708_i2c_probe(struct platform_device *pdev)
 	unsigned long bus_hz;
 	u32 cdiv;
 
+	if (pdev->dev.of_node) {
+		u32 bus_clk_rate;
+		pdev->id = of_alias_get_id(pdev->dev.of_node, "i2c");
+		if (pdev->id < 0) {
+			dev_err(&pdev->dev, "alias is missing\n");
+			return -EINVAL;
+		}
+		if (!of_property_read_u32(pdev->dev.of_node,
+					"clock-frequency", &bus_clk_rate))
+			baudrate = bus_clk_rate;
+		else
+			dev_warn(&pdev->dev,
+				"Could not read clock-frequency property\n");
+	}
+
 	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!regs) {
 		dev_err(&pdev->dev, "could not get IO memory\n");
@@ -333,6 +349,7 @@ static int bcm2708_i2c_probe(struct platform_device *pdev)
 	adap->algo = &bcm2708_i2c_algorithm;
 	adap->algo_data = bi;
 	adap->dev.parent = &pdev->dev;
+	adap->dev.of_node = pdev->dev.of_node;
 	adap->nr = pdev->id;
 	strlcpy(adap->name, dev_name(&pdev->dev), sizeof(adap->name));
 
@@ -415,10 +432,17 @@ static int bcm2708_i2c_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static const struct of_device_id bcm2708_i2c_of_match[] = {
+        { .compatible = "brcm,bcm2708-i2c" },
+        {},
+};
+MODULE_DEVICE_TABLE(of, bcm2708_i2c_of_match);
+
 static struct platform_driver bcm2708_i2c_driver = {
 	.driver		= {
 		.name	= DRV_NAME,
 		.owner	= THIS_MODULE,
+		.of_match_table = bcm2708_i2c_of_match,
 	},
 	.probe		= bcm2708_i2c_probe,
 	.remove		= bcm2708_i2c_remove,
diff --git a/drivers/i2c/busses/i2c-bcm2835.c b/drivers/i2c/busses/i2c-bcm2835.c
index ea4b08f..8beecfa 100644
--- a/drivers/i2c/busses/i2c-bcm2835.c
+++ b/drivers/i2c/busses/i2c-bcm2835.c
@@ -299,6 +299,7 @@ static int bcm2835_i2c_probe(struct platform_device *pdev)
 	strlcpy(adap->name, "bcm2835 I2C adapter", sizeof(adap->name));
 	adap->algo = &bcm2835_i2c_algo;
 	adap->dev.parent = &pdev->dev;
+	adap->dev.of_node = pdev->dev.of_node;
 
 	bcm2835_i2c_writel(i2c_dev, BCM2835_I2C_C, 0);
 
diff --git a/drivers/pinctrl/Kconfig b/drivers/pinctrl/Kconfig
index b6e864e..eac75f8 100644
--- a/drivers/pinctrl/Kconfig
+++ b/drivers/pinctrl/Kconfig
@@ -70,6 +70,11 @@ config PINCTRL_BAYTRAIL
 
 	  Requires ACPI device enumeration code to set up a platform device.
 
+config PINCTRL_BCM2708
+	bool
+	select PINMUX
+	select PINCONF
+
 config PINCTRL_BCM2835
 	bool
 	select PINMUX
diff --git a/drivers/pinctrl/Makefile b/drivers/pinctrl/Makefile
index 496d9bf..8cdb16b 100644
--- a/drivers/pinctrl/Makefile
+++ b/drivers/pinctrl/Makefile
@@ -15,6 +15,7 @@ obj-$(CONFIG_PINCTRL_AB8540)	+= pinctrl-ab8540.o
 obj-$(CONFIG_PINCTRL_AB9540)	+= pinctrl-ab9540.o
 obj-$(CONFIG_PINCTRL_AB8505)	+= pinctrl-ab8505.o
 obj-$(CONFIG_PINCTRL_AT91)	+= pinctrl-at91.o
+obj-$(CONFIG_PINCTRL_BCM2708)   += pinctrl-bcm2708.o
 obj-$(CONFIG_PINCTRL_BCM2835)	+= pinctrl-bcm2835.o
 obj-$(CONFIG_PINCTRL_BAYTRAIL)	+= pinctrl-baytrail.o
 obj-$(CONFIG_PINCTRL_IMX)	+= pinctrl-imx.o
diff --git a/drivers/pinctrl/pinctrl-bcm2708.c b/drivers/pinctrl/pinctrl-bcm2708.c
new file mode 100644
index 0000000..ae4e455
--- /dev/null
+++ b/drivers/pinctrl/pinctrl-bcm2708.c
@@ -0,0 +1,1041 @@
+/*
+ * Driver for Broadcom BCM2708 GPIO unit (pinctrl + GPIO)
+ *
+ * Copyright (C) 2012 Chris Boot, Simon Arlott, Stephen Warren
+ * Copyright (C) 2013 Noralf Tronnes
+ *
+ * This driver is copied from pinctrl-bcm2835.c
+ *
+ * This driver is inspired by:
+ * pinctrl-nomadik.c, please see original file for copyright information
+ * pinctrl-tegra.c, please see original file for copyright information
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/bitmap.h>
+#include <linux/bug.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/irqdesc.h>
+#include <linux/irqdomain.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/of_irq.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/pinctrl/machine.h>
+#include <linux/pinctrl/pinconf.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/platform_device.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+
+#define MODULE_NAME "pinctrl-bcm2708"
+#define BCM2708_NUM_GPIOS 54
+#define BCM2708_NUM_BANKS 2
+
+#define BCM2708_PIN_BITMAP_SZ \
+	DIV_ROUND_UP(BCM2708_NUM_GPIOS, sizeof(unsigned long) * 8)
+
+/* GPIO register offsets */
+#define GPFSEL0		0x0	/* Function Select */
+#define GPSET0		0x1c	/* Pin Output Set */
+#define GPCLR0		0x28	/* Pin Output Clear */
+#define GPLEV0		0x34	/* Pin Level */
+#define GPEDS0		0x40	/* Pin Event Detect Status */
+#define GPREN0		0x4c	/* Pin Rising Edge Detect Enable */
+#define GPFEN0		0x58	/* Pin Falling Edge Detect Enable */
+#define GPHEN0		0x64	/* Pin High Detect Enable */
+#define GPLEN0		0x70	/* Pin Low Detect Enable */
+#define GPAREN0		0x7c	/* Pin Async Rising Edge Detect */
+#define GPAFEN0		0x88	/* Pin Async Falling Edge Detect */
+#define GPPUD		0x94	/* Pin Pull-up/down Enable */
+#define GPPUDCLK0	0x98	/* Pin Pull-up/down Enable Clock */
+
+#define FSEL_REG(p)		(GPFSEL0 + (((p) / 10) * 4))
+#define FSEL_SHIFT(p)		(((p) % 10) * 3)
+#define GPIO_REG_OFFSET(p)	((p) / 32)
+#define GPIO_REG_SHIFT(p)	((p) % 32)
+
+enum bcm2708_pinconf_param {
+	/* argument: bcm2708_pinconf_pull */
+	BCM2708_PINCONF_PARAM_PULL,
+};
+
+enum bcm2708_pinconf_pull {
+	BCM2708_PINCONFIG_PULL_NONE,
+	BCM2708_PINCONFIG_PULL_DOWN,
+	BCM2708_PINCONFIG_PULL_UP,
+};
+
+#define BCM2708_PINCONF_PACK(_param_, _arg_) ((_param_) << 16 | (_arg_))
+#define BCM2708_PINCONF_UNPACK_PARAM(_conf_) ((_conf_) >> 16)
+#define BCM2708_PINCONF_UNPACK_ARG(_conf_) ((_conf_) & 0xffff)
+
+struct bcm2708_gpio_irqdata {
+	struct bcm2708_pinctrl *pc;
+	int bank;
+};
+
+struct bcm2708_pinctrl {
+	struct device *dev;
+	void __iomem *base;
+	int irq[BCM2708_NUM_BANKS];
+
+	/* note: locking assumes each bank will have its own unsigned long */
+	unsigned long enabled_irq_map[BCM2708_NUM_BANKS];
+	unsigned int irq_type[BCM2708_NUM_GPIOS];
+
+	struct pinctrl_dev *pctl_dev;
+	struct irq_domain *irq_domain;
+	struct gpio_chip gpio_chip;
+	struct pinctrl_gpio_range gpio_range;
+
+	struct bcm2708_gpio_irqdata irq_data[BCM2708_NUM_BANKS];
+	spinlock_t irq_lock[BCM2708_NUM_BANKS];
+};
+
+static struct lock_class_key gpio_lock_class;
+
+/* pins are just named GPIO0..GPIO53 */
+#define BCM2708_GPIO_PIN(a) PINCTRL_PIN(a, "gpio" #a)
+static struct pinctrl_pin_desc bcm2708_gpio_pins[] = {
+	BCM2708_GPIO_PIN(0),
+	BCM2708_GPIO_PIN(1),
+	BCM2708_GPIO_PIN(2),
+	BCM2708_GPIO_PIN(3),
+	BCM2708_GPIO_PIN(4),
+	BCM2708_GPIO_PIN(5),
+	BCM2708_GPIO_PIN(6),
+	BCM2708_GPIO_PIN(7),
+	BCM2708_GPIO_PIN(8),
+	BCM2708_GPIO_PIN(9),
+	BCM2708_GPIO_PIN(10),
+	BCM2708_GPIO_PIN(11),
+	BCM2708_GPIO_PIN(12),
+	BCM2708_GPIO_PIN(13),
+	BCM2708_GPIO_PIN(14),
+	BCM2708_GPIO_PIN(15),
+	BCM2708_GPIO_PIN(16),
+	BCM2708_GPIO_PIN(17),
+	BCM2708_GPIO_PIN(18),
+	BCM2708_GPIO_PIN(19),
+	BCM2708_GPIO_PIN(20),
+	BCM2708_GPIO_PIN(21),
+	BCM2708_GPIO_PIN(22),
+	BCM2708_GPIO_PIN(23),
+	BCM2708_GPIO_PIN(24),
+	BCM2708_GPIO_PIN(25),
+	BCM2708_GPIO_PIN(26),
+	BCM2708_GPIO_PIN(27),
+	BCM2708_GPIO_PIN(28),
+	BCM2708_GPIO_PIN(29),
+	BCM2708_GPIO_PIN(30),
+	BCM2708_GPIO_PIN(31),
+	BCM2708_GPIO_PIN(32),
+	BCM2708_GPIO_PIN(33),
+	BCM2708_GPIO_PIN(34),
+	BCM2708_GPIO_PIN(35),
+	BCM2708_GPIO_PIN(36),
+	BCM2708_GPIO_PIN(37),
+	BCM2708_GPIO_PIN(38),
+	BCM2708_GPIO_PIN(39),
+	BCM2708_GPIO_PIN(40),
+	BCM2708_GPIO_PIN(41),
+	BCM2708_GPIO_PIN(42),
+	BCM2708_GPIO_PIN(43),
+	BCM2708_GPIO_PIN(44),
+	BCM2708_GPIO_PIN(45),
+	BCM2708_GPIO_PIN(46),
+	BCM2708_GPIO_PIN(47),
+	BCM2708_GPIO_PIN(48),
+	BCM2708_GPIO_PIN(49),
+	BCM2708_GPIO_PIN(50),
+	BCM2708_GPIO_PIN(51),
+	BCM2708_GPIO_PIN(52),
+	BCM2708_GPIO_PIN(53),
+};
+
+/* one pin per group */
+static const char * const bcm2708_gpio_groups[] = {
+	"gpio0",
+	"gpio1",
+	"gpio2",
+	"gpio3",
+	"gpio4",
+	"gpio5",
+	"gpio6",
+	"gpio7",
+	"gpio8",
+	"gpio9",
+	"gpio10",
+	"gpio11",
+	"gpio12",
+	"gpio13",
+	"gpio14",
+	"gpio15",
+	"gpio16",
+	"gpio17",
+	"gpio18",
+	"gpio19",
+	"gpio20",
+	"gpio21",
+	"gpio22",
+	"gpio23",
+	"gpio24",
+	"gpio25",
+	"gpio26",
+	"gpio27",
+	"gpio28",
+	"gpio29",
+	"gpio30",
+	"gpio31",
+	"gpio32",
+	"gpio33",
+	"gpio34",
+	"gpio35",
+	"gpio36",
+	"gpio37",
+	"gpio38",
+	"gpio39",
+	"gpio40",
+	"gpio41",
+	"gpio42",
+	"gpio43",
+	"gpio44",
+	"gpio45",
+	"gpio46",
+	"gpio47",
+	"gpio48",
+	"gpio49",
+	"gpio50",
+	"gpio51",
+	"gpio52",
+	"gpio53",
+};
+
+enum bcm2708_fsel {
+	BCM2708_FSEL_GPIO_IN = 0,
+	BCM2708_FSEL_GPIO_OUT = 1,
+	BCM2708_FSEL_ALT0 = 4,
+	BCM2708_FSEL_ALT1 = 5,
+	BCM2708_FSEL_ALT2 = 6,
+	BCM2708_FSEL_ALT3 = 7,
+	BCM2708_FSEL_ALT4 = 3,
+	BCM2708_FSEL_ALT5 = 2,
+	BCM2708_FSEL_COUNT = 8,
+	BCM2708_FSEL_MASK = 0x7,
+};
+
+static const char * const bcm2708_functions[BCM2708_FSEL_COUNT] = {
+	[BCM2708_FSEL_GPIO_IN] = "gpio_in",
+	[BCM2708_FSEL_GPIO_OUT] = "gpio_out",
+	[BCM2708_FSEL_ALT0] = "alt0",
+	[BCM2708_FSEL_ALT1] = "alt1",
+	[BCM2708_FSEL_ALT2] = "alt2",
+	[BCM2708_FSEL_ALT3] = "alt3",
+	[BCM2708_FSEL_ALT4] = "alt4",
+	[BCM2708_FSEL_ALT5] = "alt5",
+};
+
+static const char * const irq_type_names[] = {
+	[IRQ_TYPE_NONE] = "none",
+	[IRQ_TYPE_EDGE_RISING] = "edge-rising",
+	[IRQ_TYPE_EDGE_FALLING] = "edge-falling",
+	[IRQ_TYPE_EDGE_BOTH] = "edge-both",
+	[IRQ_TYPE_LEVEL_HIGH] = "level-high",
+	[IRQ_TYPE_LEVEL_LOW] = "level-low",
+};
+
+static inline u32 bcm2708_gpio_rd(struct bcm2708_pinctrl *pc, unsigned reg)
+{
+	return readl(pc->base + reg);
+}
+
+static inline void bcm2708_gpio_wr(struct bcm2708_pinctrl *pc, unsigned reg,
+		u32 val)
+{
+	writel(val, pc->base + reg);
+}
+
+static inline int bcm2708_gpio_get_bit(struct bcm2708_pinctrl *pc, unsigned reg,
+		unsigned bit)
+{
+	reg += GPIO_REG_OFFSET(bit) * 4;
+	return (bcm2708_gpio_rd(pc, reg) >> GPIO_REG_SHIFT(bit)) & 1;
+}
+
+/* note NOT a read/modify/write cycle */
+static inline void bcm2708_gpio_set_bit(struct bcm2708_pinctrl *pc,
+		unsigned reg, unsigned bit)
+{
+	reg += GPIO_REG_OFFSET(bit) * 4;
+	bcm2708_gpio_wr(pc, reg, BIT(GPIO_REG_SHIFT(bit)));
+}
+
+static inline enum bcm2708_fsel bcm2708_pinctrl_fsel_get(
+		struct bcm2708_pinctrl *pc, unsigned pin)
+{
+	u32 val = bcm2708_gpio_rd(pc, FSEL_REG(pin));
+	enum bcm2708_fsel status = (val >> FSEL_SHIFT(pin)) & BCM2708_FSEL_MASK;
+
+	dev_dbg(pc->dev, "get %08x (%u => %s)\n", val, pin,
+			bcm2708_functions[status]);
+
+	return status;
+}
+
+static inline void bcm2708_pinctrl_fsel_set(
+		struct bcm2708_pinctrl *pc, unsigned pin,
+		enum bcm2708_fsel fsel)
+{
+	u32 val = bcm2708_gpio_rd(pc, FSEL_REG(pin));
+	enum bcm2708_fsel cur = (val >> FSEL_SHIFT(pin)) & BCM2708_FSEL_MASK;
+
+	dev_dbg(pc->dev, "read %08x (%u => %s)\n", val, pin,
+			bcm2708_functions[cur]);
+
+	if (cur == fsel)
+		return;
+
+	if (cur != BCM2708_FSEL_GPIO_IN && fsel != BCM2708_FSEL_GPIO_IN) {
+		/* always transition through GPIO_IN */
+		val &= ~(BCM2708_FSEL_MASK << FSEL_SHIFT(pin));
+		val |= BCM2708_FSEL_GPIO_IN << FSEL_SHIFT(pin);
+
+		dev_dbg(pc->dev, "trans %08x (%u <= %s)\n", val, pin,
+				bcm2708_functions[BCM2708_FSEL_GPIO_IN]);
+		bcm2708_gpio_wr(pc, FSEL_REG(pin), val);
+	}
+
+	val &= ~(BCM2708_FSEL_MASK << FSEL_SHIFT(pin));
+	val |= fsel << FSEL_SHIFT(pin);
+
+	dev_dbg(pc->dev, "write %08x (%u <= %s)\n", val, pin,
+			bcm2708_functions[fsel]);
+	bcm2708_gpio_wr(pc, FSEL_REG(pin), val);
+}
+
+static int bcm2708_gpio_request(struct gpio_chip *chip, unsigned offset)
+{
+	return pinctrl_request_gpio(chip->base + offset);
+}
+
+static void bcm2708_gpio_free(struct gpio_chip *chip, unsigned offset)
+{
+	pinctrl_free_gpio(chip->base + offset);
+}
+
+static int bcm2708_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
+{
+	return pinctrl_gpio_direction_input(chip->base + offset);
+}
+
+static int bcm2708_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	struct bcm2708_pinctrl *pc = dev_get_drvdata(chip->dev);
+
+	return bcm2708_gpio_get_bit(pc, GPLEV0, offset);
+}
+
+static int bcm2708_gpio_direction_output(struct gpio_chip *chip,
+		unsigned offset, int value)
+{
+	return pinctrl_gpio_direction_output(chip->base + offset);
+}
+
+static void bcm2708_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
+{
+	struct bcm2708_pinctrl *pc = dev_get_drvdata(chip->dev);
+
+	bcm2708_gpio_set_bit(pc, value ? GPSET0 : GPCLR0, offset);
+}
+
+static int bcm2708_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
+{
+	struct bcm2708_pinctrl *pc = dev_get_drvdata(chip->dev);
+
+	return irq_linear_revmap(pc->irq_domain, offset);
+}
+
+static struct gpio_chip bcm2708_gpio_chip = {
+	.label = MODULE_NAME,
+	.owner = THIS_MODULE,
+	.request = bcm2708_gpio_request,
+	.free = bcm2708_gpio_free,
+	.direction_input = bcm2708_gpio_direction_input,
+	.direction_output = bcm2708_gpio_direction_output,
+	.get = bcm2708_gpio_get,
+	.set = bcm2708_gpio_set,
+	.to_irq = bcm2708_gpio_to_irq,
+	.base = -1,
+	.ngpio = BCM2708_NUM_GPIOS,
+	.can_sleep = 0,
+};
+
+static irqreturn_t bcm2708_gpio_irq_handler(int irq, void *dev_id)
+{
+	struct bcm2708_gpio_irqdata *irqdata = dev_id;
+	struct bcm2708_pinctrl *pc = irqdata->pc;
+	int bank = irqdata->bank;
+	unsigned long events;
+	unsigned offset;
+	unsigned gpio;
+	unsigned int type;
+
+	events = bcm2708_gpio_rd(pc, GPEDS0 + bank * 4);
+	events &= pc->enabled_irq_map[bank];
+	for_each_set_bit(offset, &events, 32) {
+		gpio = (32 * bank) + offset;
+		type = pc->irq_type[gpio];
+
+		/* ack edge triggered IRQs immediately */
+		if (!(type & IRQ_TYPE_LEVEL_MASK))
+			bcm2708_gpio_set_bit(pc, GPEDS0, gpio);
+
+		generic_handle_irq(irq_linear_revmap(pc->irq_domain, gpio));
+
+		/* ack level triggered IRQ after handling them */
+		if (type & IRQ_TYPE_LEVEL_MASK)
+			bcm2708_gpio_set_bit(pc, GPEDS0, gpio);
+	}
+	return events ? IRQ_HANDLED : IRQ_NONE;
+}
+
+static inline void __bcm2708_gpio_irq_config(struct bcm2708_pinctrl *pc,
+	unsigned reg, unsigned offset, bool enable)
+{
+	u32 value;
+	reg += GPIO_REG_OFFSET(offset) * 4;
+	value = bcm2708_gpio_rd(pc, reg);
+	if (enable)
+		value |= BIT(GPIO_REG_SHIFT(offset));
+	else
+		value &= ~(BIT(GPIO_REG_SHIFT(offset)));
+	bcm2708_gpio_wr(pc, reg, value);
+}
+
+/* fast path for IRQ handler */
+static void bcm2708_gpio_irq_config(struct bcm2708_pinctrl *pc,
+	unsigned offset, bool enable)
+{
+	switch (pc->irq_type[offset]) {
+	case IRQ_TYPE_EDGE_RISING:
+		__bcm2708_gpio_irq_config(pc, GPREN0, offset, enable);
+		break;
+
+	case IRQ_TYPE_EDGE_FALLING:
+		__bcm2708_gpio_irq_config(pc, GPFEN0, offset, enable);
+		break;
+
+	case IRQ_TYPE_EDGE_BOTH:
+		__bcm2708_gpio_irq_config(pc, GPREN0, offset, enable);
+		__bcm2708_gpio_irq_config(pc, GPFEN0, offset, enable);
+		break;
+
+	case IRQ_TYPE_LEVEL_HIGH:
+		__bcm2708_gpio_irq_config(pc, GPHEN0, offset, enable);
+		break;
+
+	case IRQ_TYPE_LEVEL_LOW:
+		__bcm2708_gpio_irq_config(pc, GPLEN0, offset, enable);
+		break;
+	}
+}
+
+static void bcm2708_gpio_irq_enable(struct irq_data *data)
+{
+	struct bcm2708_pinctrl *pc = irq_data_get_irq_chip_data(data);
+	unsigned gpio = irqd_to_hwirq(data);
+	unsigned offset = GPIO_REG_SHIFT(gpio);
+	unsigned bank = GPIO_REG_OFFSET(gpio);
+	unsigned long flags;
+
+	spin_lock_irqsave(&pc->irq_lock[bank], flags);
+	set_bit(offset, &pc->enabled_irq_map[bank]);
+	bcm2708_gpio_irq_config(pc, gpio, true);
+	spin_unlock_irqrestore(&pc->irq_lock[bank], flags);
+}
+
+static void bcm2708_gpio_irq_disable(struct irq_data *data)
+{
+	struct bcm2708_pinctrl *pc = irq_data_get_irq_chip_data(data);
+	unsigned gpio = irqd_to_hwirq(data);
+	unsigned offset = GPIO_REG_SHIFT(gpio);
+	unsigned bank = GPIO_REG_OFFSET(gpio);
+	unsigned long flags;
+
+	spin_lock_irqsave(&pc->irq_lock[bank], flags);
+	bcm2708_gpio_irq_config(pc, gpio, false);
+	clear_bit(offset, &pc->enabled_irq_map[bank]);
+	spin_unlock_irqrestore(&pc->irq_lock[bank], flags);
+}
+
+static int __bcm2708_gpio_irq_set_type_disabled(struct bcm2708_pinctrl *pc,
+	unsigned offset, unsigned int type)
+{
+	switch (type) {
+	case IRQ_TYPE_NONE:
+	case IRQ_TYPE_EDGE_RISING:
+	case IRQ_TYPE_EDGE_FALLING:
+	case IRQ_TYPE_EDGE_BOTH:
+	case IRQ_TYPE_LEVEL_HIGH:
+	case IRQ_TYPE_LEVEL_LOW:
+		pc->irq_type[offset] = type;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/* slower path for reconfiguring IRQ type */
+static int __bcm2708_gpio_irq_set_type_enabled(struct bcm2708_pinctrl *pc,
+	unsigned offset, unsigned int type)
+{
+	switch (type) {
+	case IRQ_TYPE_NONE:
+		if (pc->irq_type[offset] != type) {
+			bcm2708_gpio_irq_config(pc, offset, false);
+			pc->irq_type[offset] = type;
+		}
+		break;
+
+	case IRQ_TYPE_EDGE_RISING:
+		if (pc->irq_type[offset] == IRQ_TYPE_EDGE_BOTH) {
+			/* RISING already enabled, disable FALLING */
+			pc->irq_type[offset] = IRQ_TYPE_EDGE_FALLING;
+			bcm2708_gpio_irq_config(pc, offset, false);
+			pc->irq_type[offset] = type;
+		} else if (pc->irq_type[offset] != type) {
+			bcm2708_gpio_irq_config(pc, offset, false);
+			pc->irq_type[offset] = type;
+			bcm2708_gpio_irq_config(pc, offset, true);
+		}
+		break;
+
+	case IRQ_TYPE_EDGE_FALLING:
+		if (pc->irq_type[offset] == IRQ_TYPE_EDGE_BOTH) {
+			/* FALLING already enabled, disable RISING */
+			pc->irq_type[offset] = IRQ_TYPE_EDGE_RISING;
+			bcm2708_gpio_irq_config(pc, offset, false);
+			pc->irq_type[offset] = type;
+		} else if (pc->irq_type[offset] != type) {
+			bcm2708_gpio_irq_config(pc, offset, false);
+			pc->irq_type[offset] = type;
+			bcm2708_gpio_irq_config(pc, offset, true);
+		}
+		break;
+
+	case IRQ_TYPE_EDGE_BOTH:
+		if (pc->irq_type[offset] == IRQ_TYPE_EDGE_RISING) {
+			/* RISING already enabled, enable FALLING too */
+			pc->irq_type[offset] = IRQ_TYPE_EDGE_FALLING;
+			bcm2708_gpio_irq_config(pc, offset, true);
+			pc->irq_type[offset] = type;
+		} else if (pc->irq_type[offset] == IRQ_TYPE_EDGE_FALLING) {
+			/* FALLING already enabled, enable RISING too */
+			pc->irq_type[offset] = IRQ_TYPE_EDGE_RISING;
+			bcm2708_gpio_irq_config(pc, offset, true);
+			pc->irq_type[offset] = type;
+		} else if (pc->irq_type[offset] != type) {
+			bcm2708_gpio_irq_config(pc, offset, false);
+			pc->irq_type[offset] = type;
+			bcm2708_gpio_irq_config(pc, offset, true);
+		}
+		break;
+
+	case IRQ_TYPE_LEVEL_HIGH:
+	case IRQ_TYPE_LEVEL_LOW:
+		if (pc->irq_type[offset] != type) {
+			bcm2708_gpio_irq_config(pc, offset, false);
+			pc->irq_type[offset] = type;
+			bcm2708_gpio_irq_config(pc, offset, true);
+		}
+		break;
+
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int bcm2708_gpio_irq_set_type(struct irq_data *data, unsigned int type)
+{
+	struct bcm2708_pinctrl *pc = irq_data_get_irq_chip_data(data);
+	unsigned gpio = irqd_to_hwirq(data);
+	unsigned offset = GPIO_REG_SHIFT(gpio);
+	unsigned bank = GPIO_REG_OFFSET(gpio);
+	unsigned long flags;
+	int ret;
+
+	spin_lock_irqsave(&pc->irq_lock[bank], flags);
+
+	if (test_bit(offset, &pc->enabled_irq_map[bank]))
+		ret = __bcm2708_gpio_irq_set_type_enabled(pc, gpio, type);
+	else
+		ret = __bcm2708_gpio_irq_set_type_disabled(pc, gpio, type);
+
+	spin_unlock_irqrestore(&pc->irq_lock[bank], flags);
+
+	return ret;
+}
+
+static struct irq_chip bcm2708_gpio_irq_chip = {
+	.name = MODULE_NAME,
+	.irq_enable = bcm2708_gpio_irq_enable,
+	.irq_disable = bcm2708_gpio_irq_disable,
+	.irq_set_type = bcm2708_gpio_irq_set_type,
+};
+
+static int bcm2708_pctl_get_groups_count(struct pinctrl_dev *pctldev)
+{
+	return ARRAY_SIZE(bcm2708_gpio_groups);
+}
+
+static const char *bcm2708_pctl_get_group_name(struct pinctrl_dev *pctldev,
+		unsigned selector)
+{
+	return bcm2708_gpio_groups[selector];
+}
+
+static int bcm2708_pctl_get_group_pins(struct pinctrl_dev *pctldev,
+		unsigned selector,
+		const unsigned **pins,
+		unsigned *num_pins)
+{
+	*pins = &bcm2708_gpio_pins[selector].number;
+	*num_pins = 1;
+
+	return 0;
+}
+
+static void bcm2708_pctl_pin_dbg_show(struct pinctrl_dev *pctldev,
+		struct seq_file *s,
+		unsigned offset)
+{
+	struct bcm2708_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
+	enum bcm2708_fsel fsel = bcm2708_pinctrl_fsel_get(pc, offset);
+	const char *fname = bcm2708_functions[fsel];
+	int value = bcm2708_gpio_get_bit(pc, GPLEV0, offset);
+	int irq = irq_find_mapping(pc->irq_domain, offset);
+
+	seq_printf(s, "function %s in %s; irq %d (%s)",
+		fname, value ? "hi" : "lo",
+		irq, irq_type_names[pc->irq_type[offset]]);
+}
+
+static void bcm2708_pctl_dt_free_map(struct pinctrl_dev *pctldev,
+		struct pinctrl_map *maps, unsigned num_maps)
+{
+	int i;
+
+	for (i = 0; i < num_maps; i++)
+		if (maps[i].type == PIN_MAP_TYPE_CONFIGS_PIN)
+			kfree(maps[i].data.configs.configs);
+
+	kfree(maps);
+}
+
+static int bcm2708_pctl_dt_node_to_map_func(struct bcm2708_pinctrl *pc,
+		struct device_node *np, u32 pin, u32 fnum,
+		struct pinctrl_map **maps)
+{
+	struct pinctrl_map *map = *maps;
+
+	if (fnum >= ARRAY_SIZE(bcm2708_functions)) {
+		dev_err(pc->dev, "%s: invalid brcm,function %d\n",
+			of_node_full_name(np), fnum);
+		return -EINVAL;
+	}
+
+	map->type = PIN_MAP_TYPE_MUX_GROUP;
+	map->data.mux.group = bcm2708_gpio_groups[pin];
+	map->data.mux.function = bcm2708_functions[fnum];
+	(*maps)++;
+
+	return 0;
+}
+
+static int bcm2708_pctl_dt_node_to_map_pull(struct bcm2708_pinctrl *pc,
+		struct device_node *np, u32 pin, u32 pull,
+		struct pinctrl_map **maps)
+{
+	struct pinctrl_map *map = *maps;
+	unsigned long *configs;
+
+	if (pull > 2) {
+		dev_err(pc->dev, "%s: invalid brcm,pull %d\n",
+			of_node_full_name(np), pull);
+		return -EINVAL;
+	}
+
+	configs = kzalloc(sizeof(*configs), GFP_KERNEL);
+	if (!configs)
+		return -ENOMEM;
+	configs[0] = BCM2708_PINCONF_PACK(BCM2708_PINCONF_PARAM_PULL, pull);
+
+	map->type = PIN_MAP_TYPE_CONFIGS_PIN;
+	map->data.configs.group_or_pin = bcm2708_gpio_pins[pin].name;
+	map->data.configs.configs = configs;
+	map->data.configs.num_configs = 1;
+	(*maps)++;
+
+	return 0;
+}
+
+static int bcm2708_pctl_dt_node_to_map(struct pinctrl_dev *pctldev,
+		struct device_node *np,
+		struct pinctrl_map **map, unsigned *num_maps)
+{
+	struct bcm2708_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
+	struct property *pins, *funcs, *pulls;
+	int num_pins, num_funcs, num_pulls, maps_per_pin;
+	struct pinctrl_map *maps, *cur_map;
+	int i, err;
+	u32 pin, func, pull;
+
+	pins = of_find_property(np, "brcm,pins", NULL);
+	if (!pins) {
+		dev_err(pc->dev, "%s: missing brcm,pins property\n",
+				of_node_full_name(np));
+		return -EINVAL;
+	}
+
+	funcs = of_find_property(np, "brcm,function", NULL);
+	pulls = of_find_property(np, "brcm,pull", NULL);
+
+	if (!funcs && !pulls) {
+		dev_err(pc->dev,
+			"%s: neither brcm,function nor brcm,pull specified\n",
+			of_node_full_name(np));
+		return -EINVAL;
+	}
+
+	num_pins = pins->length / 4;
+	num_funcs = funcs ? (funcs->length / 4) : 0;
+	num_pulls = pulls ? (pulls->length / 4) : 0;
+
+	if (num_funcs > 1 && num_funcs != num_pins) {
+		dev_err(pc->dev,
+			"%s: brcm,function must have 1 or %d entries\n",
+			of_node_full_name(np), num_pins);
+		return -EINVAL;
+	}
+
+	if (num_pulls > 1 && num_pulls != num_pins) {
+		dev_err(pc->dev,
+			"%s: brcm,pull must have 1 or %d entries\n",
+			of_node_full_name(np), num_pins);
+		return -EINVAL;
+	}
+
+	maps_per_pin = 0;
+	if (num_funcs)
+		maps_per_pin++;
+	if (num_pulls)
+		maps_per_pin++;
+	cur_map = maps = kzalloc(num_pins * maps_per_pin * sizeof(*maps),
+				GFP_KERNEL);
+	if (!maps)
+		return -ENOMEM;
+
+	for (i = 0; i < num_pins; i++) {
+		err = of_property_read_u32_index(np, "brcm,pins", i, &pin);
+		if (err)
+			goto out;
+		if (pin >= ARRAY_SIZE(bcm2708_gpio_pins)) {
+			dev_err(pc->dev, "%s: invalid brcm,pins value %d\n",
+				of_node_full_name(np), pin);
+			err = -EINVAL;
+			goto out;
+		}
+
+		if (num_funcs) {
+			err = of_property_read_u32_index(np, "brcm,function",
+					(num_funcs > 1) ? i : 0, &func);
+			if (err)
+				goto out;
+			err = bcm2708_pctl_dt_node_to_map_func(pc, np, pin,
+							func, &cur_map);
+			if (err)
+				goto out;
+		}
+		if (num_pulls) {
+			err = of_property_read_u32_index(np, "brcm,pull",
+					(num_funcs > 1) ? i : 0, &pull);
+			if (err)
+				goto out;
+			err = bcm2708_pctl_dt_node_to_map_pull(pc, np, pin,
+							pull, &cur_map);
+			if (err)
+				goto out;
+		}
+	}
+
+	*map = maps;
+	*num_maps = num_pins * maps_per_pin;
+
+	return 0;
+
+out:
+	kfree(maps);
+	return err;
+}
+
+static const struct pinctrl_ops bcm2708_pctl_ops = {
+	.get_groups_count = bcm2708_pctl_get_groups_count,
+	.get_group_name = bcm2708_pctl_get_group_name,
+	.get_group_pins = bcm2708_pctl_get_group_pins,
+	.pin_dbg_show = bcm2708_pctl_pin_dbg_show,
+	.dt_node_to_map = bcm2708_pctl_dt_node_to_map,
+	.dt_free_map = bcm2708_pctl_dt_free_map,
+};
+
+static int bcm2708_pmx_get_functions_count(struct pinctrl_dev *pctldev)
+{
+	return BCM2708_FSEL_COUNT;
+}
+
+static const char *bcm2708_pmx_get_function_name(struct pinctrl_dev *pctldev,
+		unsigned selector)
+{
+	return bcm2708_functions[selector];
+}
+
+static int bcm2708_pmx_get_function_groups(struct pinctrl_dev *pctldev,
+		unsigned selector,
+		const char * const **groups,
+		unsigned * const num_groups)
+{
+	/* every pin can do every function */
+	*groups = bcm2708_gpio_groups;
+	*num_groups = ARRAY_SIZE(bcm2708_gpio_groups);
+
+	return 0;
+}
+
+static int bcm2708_pmx_enable(struct pinctrl_dev *pctldev,
+		unsigned func_selector,
+		unsigned group_selector)
+{
+	struct bcm2708_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
+
+	bcm2708_pinctrl_fsel_set(pc, group_selector, func_selector);
+
+	return 0;
+}
+
+static void bcm2708_pmx_disable(struct pinctrl_dev *pctldev,
+		unsigned func_selector,
+		unsigned group_selector)
+{
+	struct bcm2708_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
+
+	/* disable by setting to GPIO_IN */
+	bcm2708_pinctrl_fsel_set(pc, group_selector, BCM2708_FSEL_GPIO_IN);
+}
+
+static void bcm2708_pmx_gpio_disable_free(struct pinctrl_dev *pctldev,
+		struct pinctrl_gpio_range *range,
+		unsigned offset)
+{
+	struct bcm2708_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
+
+	/* disable by setting to GPIO_IN */
+	bcm2708_pinctrl_fsel_set(pc, offset, BCM2708_FSEL_GPIO_IN);
+}
+
+static int bcm2708_pmx_gpio_set_direction(struct pinctrl_dev *pctldev,
+		struct pinctrl_gpio_range *range,
+		unsigned offset,
+		bool input)
+{
+	struct bcm2708_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
+	enum bcm2708_fsel fsel = input ?
+		BCM2708_FSEL_GPIO_IN : BCM2708_FSEL_GPIO_OUT;
+
+	bcm2708_pinctrl_fsel_set(pc, offset, fsel);
+
+	return 0;
+}
+
+static const struct pinmux_ops bcm2708_pmx_ops = {
+	.get_functions_count = bcm2708_pmx_get_functions_count,
+	.get_function_name = bcm2708_pmx_get_function_name,
+	.get_function_groups = bcm2708_pmx_get_function_groups,
+	.enable = bcm2708_pmx_enable,
+	.disable = bcm2708_pmx_disable,
+	.gpio_disable_free = bcm2708_pmx_gpio_disable_free,
+	.gpio_set_direction = bcm2708_pmx_gpio_set_direction,
+};
+
+static int bcm2708_pinconf_get(struct pinctrl_dev *pctldev,
+			unsigned pin, unsigned long *config)
+{
+	/* No way to read back config in HW */
+	return -ENOTSUPP;
+}
+
+static int bcm2708_pinconf_set(struct pinctrl_dev *pctldev,
+			unsigned pin, unsigned long *configs,
+			unsigned num_configs)
+{
+	struct bcm2708_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
+	enum bcm2708_pinconf_param param;
+	u16 arg;
+	u32 off, bit;
+	int i;
+
+	for (i = 0; i < num_configs; i++) {
+		param = BCM2708_PINCONF_UNPACK_PARAM(configs[i]);
+		arg = BCM2708_PINCONF_UNPACK_ARG(configs[i]);
+
+		dev_dbg(pc->dev, "configure pin %u (%s) = %04X\n", pin, bcm2708_gpio_groups[pin], arg);
+		if (param != BCM2708_PINCONF_PARAM_PULL)
+			return -EINVAL;
+
+		off = GPIO_REG_OFFSET(pin);
+		bit = GPIO_REG_SHIFT(pin);
+
+		bcm2708_gpio_wr(pc, GPPUD, arg & 3);
+		/*
+		 * Docs say to wait 150 cycles, but not of what. We assume a
+		 * 1 MHz clock here, which is pretty slow...
+		 */
+		udelay(150);
+		bcm2708_gpio_wr(pc, GPPUDCLK0 + (off * 4), BIT(bit));
+		udelay(150);
+		bcm2708_gpio_wr(pc, GPPUDCLK0 + (off * 4), 0);
+	} /* for each config */
+
+	return 0;
+}
+
+static const struct pinconf_ops bcm2708_pinconf_ops = {
+	.pin_config_get = bcm2708_pinconf_get,
+	.pin_config_set = bcm2708_pinconf_set,
+};
+
+static struct pinctrl_desc bcm2708_pinctrl_desc = {
+	.name = MODULE_NAME,
+	.pins = bcm2708_gpio_pins,
+	.npins = ARRAY_SIZE(bcm2708_gpio_pins),
+	.pctlops = &bcm2708_pctl_ops,
+	.pmxops = &bcm2708_pmx_ops,
+	.confops = &bcm2708_pinconf_ops,
+	.owner = THIS_MODULE,
+};
+
+static struct pinctrl_gpio_range bcm2708_pinctrl_gpio_range = {
+	.name = MODULE_NAME,
+	.npins = BCM2708_NUM_GPIOS,
+};
+
+
+
+static int bcm2708_pinctrl_gpiochip_find(struct gpio_chip *gc, void *data)
+{
+	pr_debug("%s: base = %d\n", __func__, gc->base);
+	return gc->base == 0 ? 1 : 0;
+}
+
+static int bcm2708_pinctrl_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct bcm2708_pinctrl *pc;
+	struct gpio_chip *gc;
+	struct resource iomem;
+	int err;
+	BUILD_BUG_ON(ARRAY_SIZE(bcm2708_gpio_pins) != BCM2708_NUM_GPIOS);
+	BUILD_BUG_ON(ARRAY_SIZE(bcm2708_gpio_groups) != BCM2708_NUM_GPIOS);
+
+	gc = gpiochip_find(NULL, bcm2708_pinctrl_gpiochip_find);
+	if (!gc)
+		return -EPROBE_DEFER;
+
+	gc->of_node = np;
+	gc->of_gpio_n_cells = 2;
+	gc->of_xlate = of_gpio_simple_xlate;
+
+	pc = devm_kzalloc(dev, sizeof(*pc), GFP_KERNEL);
+	if (!pc)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, pc);
+	pc->dev = dev;
+
+	err = of_address_to_resource(np, 0, &iomem);
+	if (err) {
+		dev_err(dev, "could not get IO memory\n");
+		return err;
+	}
+
+	pc->base = devm_ioremap_resource(dev, &iomem);
+	if (IS_ERR(pc->base))
+		return PTR_ERR(pc->base);
+
+	pc->gpio_chip = *gc;
+
+	pc->pctl_dev = pinctrl_register(&bcm2708_pinctrl_desc, dev, pc);
+	if (!pc->pctl_dev)
+		return -EINVAL;
+
+	pc->gpio_range = bcm2708_pinctrl_gpio_range;
+	pc->gpio_range.base = pc->gpio_chip.base;
+	pc->gpio_range.gc = &pc->gpio_chip;
+	pinctrl_add_gpio_range(pc->pctl_dev, &pc->gpio_range);
+
+	return 0;
+}
+
+static int bcm2708_pinctrl_remove(struct platform_device *pdev)
+{
+	struct bcm2708_pinctrl *pc = platform_get_drvdata(pdev);
+
+	pinctrl_unregister(pc->pctl_dev);
+	gpiochip_remove(&pc->gpio_chip);
+
+	return 0;
+}
+
+static struct of_device_id bcm2708_pinctrl_match[] = {
+	{ .compatible = "brcm,bcm2708-gpio" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, bcm2708_pinctrl_match);
+
+static struct platform_driver bcm2708_pinctrl_driver = {
+	.probe = bcm2708_pinctrl_probe,
+	.remove = bcm2708_pinctrl_remove,
+	.driver = {
+		.name = MODULE_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = bcm2708_pinctrl_match,
+	},
+};
+module_platform_driver(bcm2708_pinctrl_driver);
+
+MODULE_AUTHOR("Chris Boot, Simon Arlott, Stephen Warren, Noralf Tronnes");
+MODULE_DESCRIPTION("BCM2708 Pin control driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 41ad35a..e0f4f4b 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -76,7 +76,7 @@ config SPI_ATMEL
 
 config SPI_BCM2835
 	tristate "BCM2835 SPI controller"
-	depends on ARCH_BCM2835 || COMPILE_TEST
+	depends on (ARCH_BCM2835 || MACH_BCM2708) || COMPILE_TEST
 	help
 	  This selects a driver for the Broadcom BCM2835 SPI master.
 
diff --git a/drivers/spi/spi-bcm2708.c b/drivers/spi/spi-bcm2708.c
index d889e7f..bc60b02 100644
--- a/drivers/spi/spi-bcm2708.c
+++ b/drivers/spi/spi-bcm2708.c
@@ -512,6 +512,7 @@ static int bcm2708_spi_probe(struct platform_device *pdev)
 	master->setup = bcm2708_spi_setup;
 	master->transfer = bcm2708_spi_transfer;
 	master->cleanup = bcm2708_spi_cleanup;
+	master->dev.of_node = pdev->dev.of_node;
 	platform_set_drvdata(pdev, master);
 
 	bs = spi_master_get_devdata(master);
@@ -545,7 +546,7 @@ static int bcm2708_spi_probe(struct platform_device *pdev)
 	}
 
 	/* initialise the hardware */
-	clk_enable(clk);
+	clk_prepare_enable(clk);
 	bcm2708_wr(bs, SPI_CS, SPI_CS_REN | SPI_CS_CLEAR_RX | SPI_CS_CLEAR_TX);
 
 	err = spi_register_master(master);
@@ -560,6 +561,7 @@ static int bcm2708_spi_probe(struct platform_device *pdev)
 	return 0;
 
 out_free_irq:
+	clk_disable_unprepare(bs->clk);
 	free_irq(bs->irq, master);
 out_workqueue:
 	destroy_workqueue(bs->workq);
@@ -585,7 +587,7 @@ static int bcm2708_spi_remove(struct platform_device *pdev)
 
 	flush_work_sync(&bs->work);
 
-	clk_disable(bs->clk);
+	clk_disable_unprepare(bs->clk);
 	clk_put(bs->clk);
 	free_irq(bs->irq, master);
 	iounmap(bs->base);
@@ -595,10 +597,17 @@ static int bcm2708_spi_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static const struct of_device_id bcm2708_spi_match[] = {
+	{ .compatible = "brcm,bcm2708-spi", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, bcm2708_spi_match);
+
 static struct platform_driver bcm2708_spi_driver = {
 	.driver		= {
 		.name	= DRV_NAME,
 		.owner	= THIS_MODULE,
+		.of_match_table	= bcm2708_spi_match,
 	},
 	.probe		= bcm2708_spi_probe,
 	.remove		= bcm2708_spi_remove,
